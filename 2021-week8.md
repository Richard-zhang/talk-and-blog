# [Data oriented design](https://medium.com/@jonathanmines/data-oriented-vs-object-oriented-design-50ef35a99056)

1. Establish what objects are.
2. Determine what types of data belong to an object.
3. Describe the functionality an object has.

# [Better Living Through Base Functors]

* base functor
  * Expr => traditional recursive definition
  * ExprF 
    * replace recursive definition with type variable a
    * Fix
    * Issue
      * NatF has kind * -> *
      * ListF has kind * -> * -> *
```haskell
type Algebra   f a = f a -> a
type Coalgebra f a = a   -> f a
```
* ```type family Base t :: * -> *```
```haskell
class (Functor (Base t)) => Recursive t where
    project :: t -> Base t t
    cata    :: Algebra (Base t) a -> t -> a
    para    :: ...
```
* similar to Fold typeclass
* use simple data type directly
* motivation: t can be [a] instead of Fix (ListF a)
  * cata has more natural definition

* Reversing the Arrows, Again
  * Recursive t ==> Corecursive t

* GHC Code generation
  * cata f = c where c = f . fmap c . project
  * name (cata f) as c as a simple function is easier for GHC to generate efficient code
  * 

# [Recursion Schemes, Part VI: Comonads, Composition and Generality](https://blog.sumtypeofway.com/posts/recursion-schemes-part-6.html)

```haskell
class Comonad w where
    extract :: w a -> a
    duplicate :: w a -> w (w a)
    extend :: (w a -> b) -> w a -> w b
```

* the essence of haskell is composition
* 